<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Лабораторная работа по компьютерной графике</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">

  <style>
    body {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .main-container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
      overflow: hidden;
    }

    .header {
      background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
      color: white;
      padding: 30px;
      text-align: center;
    }

    .navigation {
      background: #2d3748;
      padding: 15px 30px;
      border-bottom: 3px solid #1a202c;
    }

    .nav-btn {
      min-width: 80px;
    }

    .nav-btn.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-color: #fff;
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.5);
    }

    .lab-info {
      background: #f7fafc;
      padding: 20px 30px;
      border-bottom: 2px solid #e2e8f0;
    }

    .canvas-wrapper {
      background: #f7fafc;
      border: 2px solid #cbd5e0;
      border-radius: 8px;
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #canvas {
      background: white;
      border: 1px solid #a0aec0;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .controls-panel {
      background: #f7fafc;
      border: 2px solid #cbd5e0;
      border-radius: 8px;
      padding: 25px;
      overflow-y: auto;
      max-height: 700px;
    }

    .controls-panel h3 {
      color: #2d3748;
      padding-bottom: 10px;
      border-bottom: 2px solid #cbd5e0;
    }

    .btn-gradient {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border: none;
      color: white;
    }

    .btn-gradient:hover {
      background: linear-gradient(135deg, #5568d3 0%, #6a3f8f 100%);
      color: white;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }
  </style>
</head>

<body>
  <div class="main-container">
    <!-- Заголовок курса -->
    <div class="header">
      <h1 class="mb-2">Лабораторная работа 4</h1>
      <h2 class="h4 fw-light opacity-75">Сформировать В-сплайновые поверхности различного порядка на основе задающего многогранника. Обеспечить поворот сформированной поверхности вокруг осей X и Y.
      </h2>
    </div>

    <!-- Рабочая область -->
    <div class="row g-3 p-4">
      <!-- Область Canvas -->
      <div class="col-lg-8">
        <div class="canvas-wrapper">
          <canvas id="canvas" width="800" height="600"></canvas>
        </div>
      </div>

      <!-- Панель управления -->
      <div class="col-lg-4">
        <div class="controls-panel">
          <h3 class="h5 mb-3">Контроллеры</h3>

          <div id="controls">
             <div class="mb-3">
    <div class="fw-semibold mb-2">B-сплайновая поверхность (tensor-product)</div>

    <label class="form-label" for="bss_shape">Задающий многогранник (control net)</label>
    <select class="form-select" id="bss_shape">
      <option value="plane" selected>Плоскость</option>
      <option value="dome">Купол</option>
      <option value="saddle">Седло</option>
      <option value="wave">Волна</option>
    </select>

    <div class="mt-3">
      <label class="form-label" for="bss_amp">Амплитуда Z: <span id="bss_ampLabel">120</span></label>
      <input class="form-range" type="range" id="bss_amp" min="0" max="300" step="5" value="120">
    </div>

    <hr class="my-3">

    <div class="fw-semibold mb-2">Степень B-сплайна</div>

    <div class="mt-2">
      <label class="form-label" for="bss_pu">Степень по u (p): <span id="bss_puLabel">3</span></label>
      <input class="form-range" type="range" id="bss_pu" min="1" max="3" step="1" value="3">
      <div class="small text-secondary">Порядок = p+1.</div>
    </div>

    <div class="mt-2">
      <label class="form-label" for="bss_pv">Степень по v (q): <span id="bss_pvLabel">3</span></label>
      <input class="form-range" type="range" id="bss_pv" min="1" max="3" step="1" value="3">
    </div>

    <hr class="my-3">

    <div class="fw-semibold mb-2">Поворот</div>

    <div class="mt-2">
      <label class="form-label" for="bss_rx">Вокруг X (°): <span id="bss_rxLabel">25</span></label>
      <input class="form-range" type="range" id="bss_rx" min="-90" max="90" step="1" value="25">
    </div>

    <div class="mt-2">
      <label class="form-label" for="bss_ry">Вокруг Y (°): <span id="bss_ryLabel">35</span></label>
      <input class="form-range" type="range" id="bss_ry" min="-180" max="180" step="1" value="35">
    </div>

    <hr class="my-3">

    <div class="fw-semibold mb-2">Качество</div>

    <div class="mt-2">
      <label class="form-label" for="bss_nu">Семплов по u: <span id="bss_nuLabel">30</span></label>
      <input class="form-range" type="range" id="bss_nu" min="6" max="120" step="1" value="30">
    </div>

    <div class="mt-2">
      <label class="form-label" for="bss_nv">Семплов по v: <span id="bss_nvLabel">22</span></label>
      <input class="form-range" type="range" id="bss_nv" min="6" max="120" step="1" value="22">
    </div>

    <div class="mt-2">
      <label class="form-label" for="bss_scale">Масштаб: <span id="bss_scaleLabel">1.0</span></label>
      <input class="form-range" type="range" id="bss_scale" min="0.2" max="3" step="0.1" value="1">
    </div>

    <div class="form-check mt-3">
      <input class="form-check-input" type="checkbox" id="bss_showNet" checked>
      <label class="form-check-label" for="bss_showNet">Показать control net</label>
    </div>

    <div class="form-check mt-2">
      <input class="form-check-input" type="checkbox" id="bss_showAxes" checked>
      <label class="form-check-label" for="bss_showAxes">Показать оси</label>
    </div>
  </div>

  <div class="d-grid gap-2">
    <button class="btn btn-outline-secondary" id="bss_reset" type="button">Сброс</button>
  </div>

          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", () => {
    // ---------- DOM ----------
    function getEl(id) {
      const el = document.getElementById(id);
      if (!el) throw new Error(`Не найден элемент id="${id}"`);
      return el;
    }

    const canvas = getEl("canvas");
    const ctx = canvas.getContext("2d");
    if (!ctx) throw new Error("canvas.getContext('2d') вернул null.");

    const shapeEl = getEl("bss_shape");
    const ampEl = getEl("bss_amp");
    const ampLabel = getEl("bss_ampLabel");

    const puEl = getEl("bss_pu");
    const pvEl = getEl("bss_pv");
    const puLabel = getEl("bss_puLabel");
    const pvLabel = getEl("bss_pvLabel");

    const rxEl = getEl("bss_rx");
    const ryEl = getEl("bss_ry");
    const rxLabel = getEl("bss_rxLabel");
    const ryLabel = getEl("bss_ryLabel");

    const nuEl = getEl("bss_nu");
    const nvEl = getEl("bss_nv");
    const nuLabel = getEl("bss_nuLabel");
    const nvLabel = getEl("bss_nvLabel");

    const scaleEl = getEl("bss_scale");
    const scaleLabel = getEl("bss_scaleLabel");

    const showNetEl = getEl("bss_showNet");
    const showAxesEl = getEl("bss_showAxes");
    const resetBtn = getEl("bss_reset");

    // ---------- View math ----------
    const degToRad = (d) => d * Math.PI / 180;

    function rotateX(p, rad) {
      const c = Math.cos(rad), s = Math.sin(rad);
      return { x: p.x, y: p.y * c - p.z * s, z: p.y * s + p.z * c };
    }
    function rotateY(p, rad) {
      const c = Math.cos(rad), s = Math.sin(rad);
      return { x: p.x * c + p.z * s, y: p.y, z: -p.x * s + p.z * c };
    }
    function applyView(p, rx, ry) { return rotateY(rotateX(p, rx), ry); }

    function projectOrtho(pView, scale2d) {
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      return { x: cx + pView.x * scale2d, y: cy - pView.y * scale2d };
    }

    // ---------- Control net ----------
    function buildControlNet4x4(shape, amp) {
      const grid = [];
      const size = 220;

      for (let i = 0; i < 4; i++) {
        grid[i] = [];
        const u = i / 3;
        const x = (u - 0.5) * size * 2;

        for (let j = 0; j < 4; j++) {
          const v = j / 3;
          const y = (v - 0.5) * size * 2;

          const nx = (u - 0.5) * 2;
          const ny = (v - 0.5) * 2;

          let z = 0;
          if (shape === "plane") z = 0;
          else if (shape === "dome") {
            const r2 = nx*nx + ny*ny;
            z = amp * Math.max(0, 1 - r2);
          } else if (shape === "saddle") {
            z = amp * (nx*nx - ny*ny) * 0.6;
          } else if (shape === "wave") {
            z = amp * Math.sin(Math.PI * nx) * Math.sin(Math.PI * ny);
          }

          grid[i][j] = { x, y, z };
        }
      }
      return grid;
    }

    // ---------- B-spline basis (Cox–de Boor) ----------
    // N_{i,0}(u)=1 if U[i] <= u < U[i+1], else 0
    // N_{i,p}(u)=((u-U[i])/(U[i+p]-U[i])) N_{i,p-1}(u) + ((U[i+p+1]-u)/(U[i+p+1]-U[i+1])) N_{i+1,p-1}(u)
    // (Cox–de Boor recursion). [web:493][web:491]
    function bsplineBasis(i, p, u, U) {
      if (p === 0) {
        // special-case u==1 on last knot span
        const last = (i === U.length - 2) && (u === U[U.length - 1]);
        if (last) return 1;
        return (U[i] <= u && u < U[i + 1]) ? 1 : 0;
      }

      const denom1 = U[i + p] - U[i];
      const denom2 = U[i + p + 1] - U[i + 1];

      const a = denom1 !== 0 ? ((u - U[i]) / denom1) * bsplineBasis(i, p - 1, u, U) : 0;
      const b = denom2 !== 0 ? ((U[i + p + 1] - u) / denom2) * bsplineBasis(i + 1, p - 1, u, U) : 0;
      return a + b;
    }

    // Open-uniform (clamped) knot vector for n+1 control points and degree p:
    // length = (n+1) + p + 1 = n+p+2; first/last knots repeated p+1 times. [web:491][web:501]
    function makeClampedUniformKnots(numCtrl, p) {
      const n = numCtrl - 1;
      const m = n + p + 1; // last index in knot vector
      const U = new Array(m + 1);

      // first p+1 knots = 0
      for (let i = 0; i <= p; i++) U[i] = 0;

      // internal knots
      const internalCount = (m + 1) - 2 * (p + 1);
      for (let k = 1; k <= internalCount; k++) {
        U[p + k] = k / (internalCount + 1);
      }

      // last p+1 knots = 1
      for (let i = m - p; i <= m; i++) U[i] = 1;

      return U;
    }

    // Surface evaluation: S(u,v)=Σ_i Σ_j N_{i,p}(u) M_{j,q}(v) P_ij. [web:491]
    function evalBSplineSurface(P, u, v, p, q, U, V) {
      const nu = P.length;       // 4
      const nv = P[0].length;    // 4

      let x = 0, y = 0, z = 0;

      for (let i = 0; i < nu; i++) {
        const Nu = bsplineBasis(i, p, u, U);
        if (Nu === 0) continue;

        for (let j = 0; j < nv; j++) {
          const Nv = bsplineBasis(j, q, v, V);
          if (Nv === 0) continue;

          const w = Nu * Nv;
          const pij = P[i][j];
          x += w * pij.x;
          y += w * pij.y;
          z += w * pij.z;
        }
      }

      return { x, y, z };
    }

    // ---------- Drawing ----------
    function clearCanvas() {
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }

    function drawAxes(rx, ry, scale2d) {
      const L = 180;
      const O={x:0,y:0,z:0}, X={x:L,y:0,z:0}, Y={x:0,y:L,z:0}, Z={x:0,y:0,z:L};
      const axes = [
        {a:O,b:X,c:"#e53e3e"},
        {a:O,b:Y,c:"#48bb78"},
        {a:O,b:Z,c:"#667eea"}
      ];
      for (const ax of axes) {
        const A = projectOrtho(applyView(ax.a, rx, ry), scale2d);
        const B = projectOrtho(applyView(ax.b, rx, ry), scale2d);
        ctx.save();
        ctx.strokeStyle = ax.c;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(A.x,A.y);
        ctx.lineTo(B.x,B.y);
        ctx.stroke();
        ctx.restore();
      }
    }

    function drawControlNet(P, rx, ry, scale2d) {
      ctx.save();
      ctx.strokeStyle = "rgba(17,24,39,0.35)";
      ctx.lineWidth = 1.5;

      for (let i = 0; i < 4; i++) {
        ctx.beginPath();
        for (let j = 0; j < 4; j++) {
          const s = projectOrtho(applyView(P[i][j], rx, ry), scale2d);
          if (j === 0) ctx.moveTo(s.x, s.y); else ctx.lineTo(s.x, s.y);
        }
        ctx.stroke();
      }

      for (let j = 0; j < 4; j++) {
        ctx.beginPath();
        for (let i = 0; i < 4; i++) {
          const s = projectOrtho(applyView(P[i][j], rx, ry), scale2d);
          if (i === 0) ctx.moveTo(s.x, s.y); else ctx.lineTo(s.x, s.y);
        }
        ctx.stroke();
      }

      ctx.fillStyle = "rgba(17,24,39,0.75)";
      for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
          const s = projectOrtho(applyView(P[i][j], rx, ry), scale2d);
          ctx.beginPath();
          ctx.arc(s.x, s.y, 3.5, 0, Math.PI*2);
          ctx.fill();
        }
      }

      ctx.restore();
    }

    function drawSurfaceWireframe(P, rx, ry, scale2d, samplesU, samplesV, p, q, U, V) {
      ctx.save();
      ctx.strokeStyle = "#2d3748";
      ctx.lineWidth = 1.3;

      // u = const
      for (let iu = 0; iu <= samplesU; iu++) {
        const u = iu / samplesU;
        ctx.beginPath();
        for (let iv = 0; iv <= samplesV; iv++) {
          const v = iv / samplesV;
          const p3 = evalBSplineSurface(P, u, v, p, q, U, V);
          const s = projectOrtho(applyView(p3, rx, ry), scale2d);
          if (iv === 0) ctx.moveTo(s.x, s.y); else ctx.lineTo(s.x, s.y);
        }
        ctx.stroke();
      }

      // v = const
      for (let iv = 0; iv <= samplesV; iv++) {
        const v = iv / samplesV;
        ctx.beginPath();
        for (let iu = 0; iu <= samplesU; iu++) {
          const u = iu / samplesU;
          const p3 = evalBSplineSurface(P, u, v, p, q, U, V);
          const s = projectOrtho(applyView(p3, rx, ry), scale2d);
          if (iu === 0) ctx.moveTo(s.x, s.y); else ctx.lineTo(s.x, s.y);
        }
        ctx.stroke();
      }

      ctx.restore();
    }

    function render() {
      const amp = Number(ampEl.value);
      const p = Number(puEl.value);
      const q = Number(pvEl.value);

      // для сетки 4x4 степень не должна превышать 3
      const pClamped = Math.max(1, Math.min(3, p));
      const qClamped = Math.max(1, Math.min(3, q));

      const rx = degToRad(Number(rxEl.value));
      const ry = degToRad(Number(ryEl.value));

      const samplesU = Math.max(6, Number(nuEl.value));
      const samplesV = Math.max(6, Number(nvEl.value));
      const scale2d = Number(scaleEl.value);

      ampLabel.textContent = String(ampEl.value);
      puLabel.textContent = String(pClamped);
      pvLabel.textContent = String(qClamped);
      rxLabel.textContent = String(rxEl.value);
      ryLabel.textContent = String(ryEl.value);
      nuLabel.textContent = String(nuEl.value);
      nvLabel.textContent = String(nvEl.value);
      scaleLabel.textContent = String(scaleEl.value);

      const P = buildControlNet4x4(shapeEl.value, amp);

      // узловые векторы (clamped/uniform). [web:501][web:491]
      const U = makeClampedUniformKnots(4, pClamped);
      const V = makeClampedUniformKnots(4, qClamped);

      clearCanvas();
      if (showAxesEl.checked) drawAxes(rx, ry, scale2d);
      drawSurfaceWireframe(P, rx, ry, scale2d, samplesU, samplesV, pClamped, qClamped, U, V);
      if (showNetEl.checked) drawControlNet(P, rx, ry, scale2d);
    }

    // ---------- Events ----------
    [
      shapeEl, ampEl,
      puEl, pvEl,
      rxEl, ryEl,
      nuEl, nvEl,
      scaleEl,
      showNetEl, showAxesEl
    ].forEach(el => {
      el.addEventListener("input", render);
      el.addEventListener("change", render);
    });

    resetBtn.addEventListener("click", () => {
      shapeEl.value = "plane";
      ampEl.value = "120";
      puEl.value = "3";
      pvEl.value = "3";
      rxEl.value = "25";
      ryEl.value = "35";
      nuEl.value = "30";
      nvEl.value = "22";
      scaleEl.value = "1";
      showNetEl.checked = true;
      showAxesEl.checked = true;
      render();
    });

    render();
  });
</script>

</body>

</html>