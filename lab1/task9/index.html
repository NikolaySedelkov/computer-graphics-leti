<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Лабораторная работа по компьютерной графике</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">

  <style>
    body {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .main-container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
      overflow: hidden;
    }

    .header {
      background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
      color: white;
      padding: 30px;
      text-align: center;
    }

    .navigation {
      background: #2d3748;
      padding: 15px 30px;
      border-bottom: 3px solid #1a202c;
    }

    .nav-btn {
      min-width: 80px;
    }

    .nav-btn.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-color: #fff;
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.5);
    }

    .lab-info {
      background: #f7fafc;
      padding: 20px 30px;
      border-bottom: 2px solid #e2e8f0;
    }

    .canvas-wrapper {
      background: #f7fafc;
      border: 2px solid #cbd5e0;
      border-radius: 8px;
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #canvas {
      background: white;
      border: 1px solid #a0aec0;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .controls-panel {
      background: #f7fafc;
      border: 2px solid #cbd5e0;
      border-radius: 8px;
      padding: 25px;
      overflow-y: auto;
      max-height: 700px;
    }

    .controls-panel h3 {
      color: #2d3748;
      padding-bottom: 10px;
      border-bottom: 2px solid #cbd5e0;
    }

    .btn-gradient {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border: none;
      color: white;
    }

    .btn-gradient:hover {
      background: linear-gradient(135deg, #5568d3 0%, #6a3f8f 100%);
      color: white;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }
  </style>
</head>

<body>
  <div class="main-container">
    <!-- Заголовок курса -->
    <div class="header">
      <h1 class="mb-2">Лабораторная работа 1</h1>
      <h2 class="h4 fw-light opacity-75">Сформировать отрезок, проведенный из произвольно расположенной
        точки на плоскости к заданной окружности, определив предварительно координаты точки касания. Необходимо
        предусмотреть возможность редактирования положения точки и параметры окружности.
      </h2>
    </div>

    <!-- Рабочая область -->
    <div class="row g-3 p-4">
      <!-- Область Canvas -->
      <div class="col-lg-8">
        <div class="canvas-wrapper">
          <canvas id="canvas" width="800" height="600"></canvas>
        </div>
      </div>

      <!-- Панель управления -->
      <div class="col-lg-4">
        <div class="controls-panel">
          <h3 class="h5 mb-3">Контроллеры</h3>

          <div id="controls">
            <div class="mb-3">
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="tan_showSecond" checked>
                <label class="form-check-label" for="tan_showSecond">Показать обе касательные (если существуют)</label>
              </div>

              <div class="form-check mt-2">
                <input class="form-check-input" type="checkbox" id="tan_showHelpers" checked>
                <label class="form-check-label" for="tan_showHelpers">Показать вспомогательные линии</label>
              </div>

              <hr class="my-3">

              <div class="mt-2">
                <label class="form-label" for="tan_radius">
                  Радиус окружности: <span id="tan_radiusLabel">120</span>
                </label>
                <input class="form-range" type="range" id="tan_radius" min="10" max="300" step="1" value="120">
              </div>

              <hr class="my-3">
              <div class="small text-secondary">
                Перетаскивание: синяя точка — P, красная — центр окружности C.
              </div>
            </div>

            <div class="d-grid gap-2">
              <button class="btn btn-outline-secondary" id="tan_reset" type="button">Сброс</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // ---------- DOM ----------
        function requireEl(id) {
          const n = document.getElementById(id);
          if (!n) throw new Error(`Не найден элемент id="${id}"`);
          return n;
        }

        const canvas = requireEl("canvas");
        const ctx = canvas.getContext("2d");
        if (!ctx) throw new Error("canvas.getContext('2d') вернул null.");

        const showSecondEl = requireEl("tan_showSecond");
        const showHelpersEl = requireEl("tan_showHelpers");

        const rEl = requireEl("tan_radius");
        const rLabel = requireEl("tan_radiusLabel");

        const resetBtn = requireEl("tan_reset");

        // ---------- World mapping (0,0 center; Y up) ----------
        function clearCanvas() {
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function withWorld(drawFn) {
          const cx = canvas.width / 2;
          const cy = canvas.height / 2;
          ctx.save();
          ctx.setTransform(1, 0, 0, -1, cx, cy);
          drawFn();
          ctx.restore();
        }

        function screenToWorld(clientX, clientY) {
          const rect = canvas.getBoundingClientRect();
          const px = (clientX - rect.left) * (canvas.width / rect.width);
          const py = (clientY - rect.top) * (canvas.height / rect.height);
          const cx = canvas.width / 2;
          const cy = canvas.height / 2;
          return { x: px - cx, y: cy - py };
        }

        // ---------- Geometry helpers ----------
        function sub(a, b) { return { x: a.x - b.x, y: a.y - b.y }; }
        function add(a, b) { return { x: a.x + b.x, y: a.y + b.y }; }
        function mul(a, s) { return { x: a.x * s, y: a.y * s }; }
        function dot(a, b) { return a.x * b.x + a.y * b.y; }
        function norm(a) { return Math.hypot(a.x, a.y); }
        function normalize(a) { const n = norm(a) || 1; return { x: a.x / n, y: a.y / n }; }
        function perp(a) { return { x: -a.y, y: a.x }; } // поворот на +90°

        function dist2(a, b) { const dx = a.x - b.x, dy = a.y - b.y; return dx * dx + dy * dy; }

        // Точки касания из внешней точки P к окружности (C,r). [web:377]
        function tangentPointsFromPointToCircle(P, C, r) {
          const v = sub(P, C);
          const d = norm(v);

          // внутри окружности -> касательных нет
          if (d < r - 1e-9) return { kind: "inside", points: [] };

          // на окружности -> одна касательная (точка касания = P)
          if (Math.abs(d - r) <= 1e-9) return { kind: "on", points: [{ x: P.x, y: P.y }] };

          // снаружи -> две касательные
          const u = normalize(v);
          const n = perp(u);

          const a = (r * r) / d;
          const h = (r * Math.sqrt(d * d - r * r)) / d;

          const T1 = add(C, add(mul(u, a), mul(n, h)));
          const T2 = add(C, add(mul(u, a), mul(n, -h)));

          return { kind: "outside", points: [T1, T2] };
        }

        // ---------- State ----------
        let C = { x: 0, y: 0 };
        let P = { x: 220, y: 120 };
        let radius = 120;

        // ---------- Drawing ----------
        function drawAxes() {
          withWorld(() => {
            ctx.strokeStyle = "#e2e8f0";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, 0);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, -canvas.height / 2);
            ctx.lineTo(0, canvas.height / 2);
            ctx.stroke();
          });
        }

        function drawCircle(C, r) {
          withWorld(() => {
            ctx.strokeStyle = "#2d3748";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(C.x, C.y, r, 0, Math.PI * 2);
            ctx.stroke();
          });
        }

        function drawPoint(pt, color) {
          withWorld(() => {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(pt.x, pt.y, 6, 0, Math.PI * 2);
            ctx.fill();
          });
        }

        function drawSegment(a, b, style, width = 2, dashed = false) {
          withWorld(() => {
            ctx.save();
            ctx.strokeStyle = style;
            ctx.lineWidth = width;
            ctx.setLineDash(dashed ? [6, 6] : []);
            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(b.x, b.y);
            ctx.stroke();
            ctx.restore();
          });
        }

        function drawStatusText(text) {
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.fillStyle = "#2d3748";
          ctx.font = "14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
          ctx.fillText(text, 12, 20);
          ctx.restore();
        }

        function render() {
          radius = Number(rEl.value);
          rLabel.textContent = String(radius);

          clearCanvas();
          drawAxes();
          drawCircle(C, radius);

          // вычисляем касания
          const tang = tangentPointsFromPointToCircle(P, C, radius);

          if (tang.kind === "inside") {
            drawStatusText("Точка P внутри окружности — касательных нет.");
          } else if (tang.kind === "on") {
            drawStatusText("Точка P на окружности — одна касательная.");
          } else {
            drawStatusText("Точка P вне окружности — две касательные.");
          }

          // вспомогательная линия CP
          if (showHelpersEl.checked) {
            drawSegment(C, P, "rgba(45,55,72,0.35)", 1.5, true);
          }

          // рисуем касательные
          if (tang.points.length >= 1) {
            const T1 = tang.points[0];
            drawSegment(P, T1, "#667eea", 2.5, false);
            if (showHelpersEl.checked) drawSegment(C, T1, "rgba(72,187,120,0.5)", 1.5, false); // радиус к касанию
            drawPoint(T1, "#667eea");
          }

          if (showSecondEl.checked && tang.points.length >= 2) {
            const T2 = tang.points[1];
            drawSegment(P, T2, "#667eea", 2.5, false);
            if (showHelpersEl.checked) drawSegment(C, T2, "rgba(72,187,120,0.5)", 1.5, false);
            drawPoint(T2, "#667eea");
          }

          // точки P и C
          drawPoint(C, "#e53e3e");
          drawPoint(P, "#3182ce");
        }

        // ---------- Interaction (drag P and C) ----------
        const DragKind = { NONE: 0, POINT_P: 1, CENTER_C: 2 };
        const drag = { kind: DragKind.NONE };
        const HIT_R2 = 14 * 14;

        canvas.addEventListener("mousedown", (evt) => {
          const w = screenToWorld(evt.clientX, evt.clientY);

          if (dist2(w, P) <= HIT_R2) { drag.kind = DragKind.POINT_P; evt.preventDefault(); return; }
          if (dist2(w, C) <= HIT_R2) { drag.kind = DragKind.CENTER_C; evt.preventDefault(); return; }
        });

        canvas.addEventListener("mousemove", (evt) => {
          if (drag.kind === DragKind.NONE) return;
          const w = screenToWorld(evt.clientX, evt.clientY);

          if (drag.kind === DragKind.POINT_P) P = { x: w.x, y: w.y };
          if (drag.kind === DragKind.CENTER_C) C = { x: w.x, y: w.y };

          render();
        });

        function stopDrag() { drag.kind = DragKind.NONE; }
        window.addEventListener("mouseup", stopDrag);
        canvas.addEventListener("mouseleave", stopDrag);

        // ---------- Controls ----------
        [showSecondEl, showHelpersEl, rEl].forEach((n) => {
          n.addEventListener("input", render);
          n.addEventListener("change", render);
        });

        resetBtn.addEventListener("click", () => {
          C = { x: 0, y: 0 };
          P = { x: 220, y: 120 };
          rEl.value = "120";
          showSecondEl.checked = true;
          showHelpersEl.checked = true;
          render();
        });

        render();
      });
    </script>


</body>

</html>