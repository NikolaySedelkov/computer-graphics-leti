<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Лабораторная работа по компьютерной графике</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">

  <style>
    body {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .main-container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
      overflow: hidden;
    }

    .header {
      background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
      color: white;
      padding: 30px;
      text-align: center;
    }

    .navigation {
      background: #2d3748;
      padding: 15px 30px;
      border-bottom: 3px solid #1a202c;
    }

    .nav-btn {
      min-width: 80px;
    }

    .nav-btn.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-color: #fff;
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.5);
    }

    .lab-info {
      background: #f7fafc;
      padding: 20px 30px;
      border-bottom: 2px solid #e2e8f0;
    }

    .canvas-wrapper {
      background: #f7fafc;
      border: 2px solid #cbd5e0;
      border-radius: 8px;
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #canvas {
      background: white;
      border: 1px solid #a0aec0;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .controls-panel {
      background: #f7fafc;
      border: 2px solid #cbd5e0;
      border-radius: 8px;
      padding: 25px;
      overflow-y: auto;
      max-height: 700px;
    }

    .controls-panel h3 {
      color: #2d3748;
      padding-bottom: 10px;
      border-bottom: 2px solid #cbd5e0;
    }

    .btn-gradient {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border: none;
      color: white;
    }

    .btn-gradient:hover {
      background: linear-gradient(135deg, #5568d3 0%, #6a3f8f 100%);
      color: white;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }
  </style>
</head>

<body>
  <div class="main-container">
    <!-- Заголовок курса -->
    <div class="header">
      <h1 class="mb-2">Лабораторная работа 1</h1>
      <h2 class="h4 fw-light opacity-75">Построение диметрической и изометрической проекции заданного объемного тела.
        оси.
      </h2>
    </div>

    <!-- Рабочая область -->
    <div class="row g-3 p-4">
      <!-- Область Canvas -->
      <div class="col-lg-8">
        <div class="canvas-wrapper">
          <canvas id="canvas" width="800" height="600"></canvas>
        </div>
      </div>

      <!-- Панель управления -->
      <div class="col-lg-4">
        <div class="controls-panel">
          <h3 class="h5 mb-3">Контроллеры</h3>

          <div id="controls">
             <div class="mb-3">
    <label class="form-label" for="axon_body">Тело</label>
    <select class="form-select" id="axon_body">
      <option value="cube" selected>Куб</option>
      <option value="box">Параллелепипед</option>
      <option value="pyramid">Пирамида (квадратное основание)</option>
    </select>

    <div class="form-check mt-3">
      <input class="form-check-input" type="checkbox" id="axon_splitView" checked>
      <label class="form-check-label" for="axon_splitView">Показать обе проекции (изо + димо)</label>
    </div>

    <hr class="my-3">

    <div class="mt-2">
      <label class="form-label" for="axon_dimCoeff">
        Диметрический коэффициент (coeff): <span id="axon_dimCoeffLabel">2</span>
      </label>
      <input class="form-range" type="range" id="axon_dimCoeff" min="1" max="5" step="0.1" value="2">
      <div class="small text-secondary">
        Диметрия: \(k_x=k_y=1\), \(k_z=1/coeff\) (при coeff=2 → 0.5). [web:300]
      </div>
    </div>

    <hr class="my-3">

    <div class="fw-semibold mb-2">Поворот вида (общий)</div>

    <div class="mt-1">
      <label class="form-label" for="axon_viewX">Вид: вокруг X (°): <span id="axon_viewXLabel">35.264</span></label>
      <input class="form-range" type="range" id="axon_viewX" min="-90" max="90" step="0.1" value="35.264">
    </div>

    <div class="mt-2">
      <label class="form-label" for="axon_viewY">Вид: вокруг Y (°): <span id="axon_viewYLabel">45</span></label>
      <input class="form-range" type="range" id="axon_viewY" min="-180" max="180" step="0.1" value="45">
    </div>

    <div class="mt-2">
      <label class="form-label" for="axon_viewZ">Вид: вокруг Z (°): <span id="axon_viewZLabel">0</span></label>
      <input class="form-range" type="range" id="axon_viewZ" min="-180" max="180" step="0.1" value="0">
    </div>

    <hr class="my-3">

    <div class="form-check">
      <input class="form-check-input" type="checkbox" id="axon_showAxes" checked>
      <label class="form-check-label" for="axon_showAxes">Показать оси</label>
    </div>

    <div class="mt-3">
      <label class="form-label" for="axon_scale">Масштаб: <span id="axon_scaleLabel">1.0</span></label>
      <input class="form-range" type="range" id="axon_scale" min="0.3" max="3" step="0.1" value="1">
    </div>
  </div>

  <div class="d-grid gap-2">
    <button class="btn btn-outline-secondary" id="axon_reset" type="button">Сброс</button>
  </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", () => {
    // ---------- DOM ----------
    function requireEl(id) {
      const n = document.getElementById(id);
      if (!n) throw new Error(`Не найден элемент id="${id}". Проверьте HTML.`);
      return n;
    }

    const canvas = requireEl("canvas");
    const ctx = canvas.getContext("2d");
    if (!ctx) throw new Error("canvas.getContext('2d') вернул null.");

    const bodyEl = requireEl("axon_body");
    const splitEl = requireEl("axon_splitView");

    const dimCoeffEl = requireEl("axon_dimCoeff");
    const dimCoeffLabel = requireEl("axon_dimCoeffLabel");

    const viewXEl = requireEl("axon_viewX");
    const viewYEl = requireEl("axon_viewY");
    const viewZEl = requireEl("axon_viewZ");
    const viewXLabel = requireEl("axon_viewXLabel");
    const viewYLabel = requireEl("axon_viewYLabel");
    const viewZLabel = requireEl("axon_viewZLabel");

    const showAxesEl = requireEl("axon_showAxes");

    const scaleEl = requireEl("axon_scale");
    const scaleLabel = requireEl("axon_scaleLabel");

    const resetBtn = requireEl("axon_reset");

    // ---------- Math ----------
    const degToRad = (d) => d * Math.PI / 180;

    function rotateX(p, rad) {
      const c = Math.cos(rad), s = Math.sin(rad);
      return { x: p.x, y: p.y * c - p.z * s, z: p.y * s + p.z * c };
    }
    function rotateY(p, rad) {
      const c = Math.cos(rad), s = Math.sin(rad);
      return { x: p.x * c + p.z * s, y: p.y, z: -p.x * s + p.z * c };
    }
    function rotateZ(p, rad) {
      const c = Math.cos(rad), s = Math.sin(rad);
      return { x: p.x * c - p.y * s, y: p.x * s + p.y * c, z: p.z };
    }
    function applyRotationXYZ(p, rx, ry, rz) {
      let v = rotateX(p, rx);
      v = rotateY(v, ry);
      v = rotateZ(v, rz);
      return v;
    }

    // “Строго по определению” через коэффициенты: dim => kx=ky=1, kz=1/coeff. [web:277][web:300]
    function distortWorld(pWorld, mode, coeff) {
      if (mode === "dim") return { x: pWorld.x, y: pWorld.y, z: pWorld.z * (1 / coeff) };
      return pWorld; // iso: kx=ky=kz
    }

    // orthographic after view rotation (axonometric = parallel projection). [web:338]
    function projectOrtho(pView, scale2d, viewport) {
      const { x0, y0, w, h } = viewport;
      const cx = x0 + w / 2;
      const cy = y0 + h / 2;
      return { x: cx + pView.x * scale2d, y: cy - pView.y * scale2d, ok: true };
    }

    // ---------- Bodies (vertices + edges) ----------
    function makeCube(s = 80) {
      const a = -s, b = s;
      const v = [
        {x:a,y:a,z:a},{x:b,y:a,z:a},{x:b,y:b,z:a},{x:a,y:b,z:a},
        {x:a,y:a,z:b},{x:b,y:a,z:b},{x:b,y:b,z:b},{x:a,y:b,z:b}
      ];
      const e = [[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
      return { vertices: v, edges: e };
    }

    function makeBox(sx=110, sy=70, sz=50) {
      const ax=-sx, bx=sx, ay=-sy, by=sy, az=-sz, bz=sz;
      const v = [
        {x:ax,y:ay,z:az},{x:bx,y:ay,z:az},{x:bx,y:by,z:az},{x:ax,y:by,z:az},
        {x:ax,y:ay,z:bz},{x:bx,y:ay,z:bz},{x:bx,y:by,z:bz},{x:ax,y:by,z:bz}
      ];
      const e = [[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
      return { vertices: v, edges: e };
    }

    function makePyramid(base=120, height=140) {
      const a = -base/2, b = base/2, z0 = -60;
      const v = [
        {x:a,y:a,z:z0}, {x:b,y:a,z:z0}, {x:b,y:b,z:z0}, {x:a,y:b,z:z0},
        {x:0,y:0,z:z0 + height}
      ];
      const e = [
        [0,1],[1,2],[2,3],[3,0],
        [0,4],[1,4],[2,4],[3,4]
      ];
      return { vertices: v, edges: e };
    }

    function getBody() {
      const kind = bodyEl.value;
      if (kind === "cube") return makeCube(80);
      if (kind === "box") return makeBox();
      if (kind === "pyramid") return makePyramid();
      return makeCube(80);
    }

    // ---------- Draw helpers ----------
    function clearCanvas() {
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }

    function drawWireframe(projected, edges, style, width=2) {
      ctx.save();
      ctx.strokeStyle = style;
      ctx.lineWidth = width;
      for (const [i,j] of edges) {
        const a = projected[i], b = projected[j];
        if (!a.ok || !b.ok) continue;
        ctx.beginPath();
        ctx.moveTo(a.x,a.y);
        ctx.lineTo(b.x,b.y);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawTitle(text, viewport) {
      ctx.save();
      ctx.fillStyle = "#2d3748";
      ctx.font = "14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText(text, viewport.x0 + 10, viewport.y0 + 18);
      ctx.restore();
    }

    function drawViewportBorder(viewport) {
      ctx.save();
      ctx.strokeStyle = "#e2e8f0";
      ctx.lineWidth = 1;
      ctx.strokeRect(viewport.x0 + 0.5, viewport.y0 + 0.5, viewport.w - 1, viewport.h - 1);
      ctx.restore();
    }

    function drawAxes(mode, coeff, rx, ry, rz, scale2d, viewport) {
      const origin = {x:0,y:0,z:0};
      const L = 140;
      const axes = [
        { p: origin, q: {x:L,y:0,z:0}, c: "#e53e3e" },
        { p: origin, q: {x:0,y:L,z:0}, c: "#48bb78" },
        { p: origin, q: {x:0,y:0,z:L}, c: "#667eea" }
      ];

      for (const ax of axes) {
        const pw = distortWorld(ax.p, mode, coeff);
        const qw = distortWorld(ax.q, mode, coeff);

        const pv = applyRotationXYZ(pw, rx, ry, rz);
        const qv = applyRotationXYZ(qw, rx, ry, rz);

        const P = projectOrtho(pv, scale2d, viewport);
        const Q = projectOrtho(qv, scale2d, viewport);

        ctx.save();
        ctx.strokeStyle = ax.c;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(P.x, P.y);
        ctx.lineTo(Q.x, Q.y);
        ctx.stroke();
        ctx.restore();
      }
    }

    function buildProjected(body, mode, coeff, rx, ry, rz, scale2d, viewport) {
      return body.vertices
        .map(p => distortWorld(p, mode, coeff))         // коэффициенты (definition) [web:277]
        .map(p2 => applyRotationXYZ(p2, rx, ry, rz))    // поворот вида
        .map(v => projectOrtho(v, scale2d, viewport));  // параллельная проекция [web:338]
    }

    function updateLabels() {
      dimCoeffLabel.textContent = String(dimCoeffEl.value);
      viewXLabel.textContent = String(viewXEl.value);
      viewYLabel.textContent = String(viewYEl.value);
      viewZLabel.textContent = String(viewZEl.value);
      scaleLabel.textContent = String(scaleEl.value);
    }

    // ---------- Render ----------
    function render() {
      updateLabels();

      const body = getBody();
      const coeff = Math.max(1e-6, Number(dimCoeffEl.value));
      const scale2d = Number(scaleEl.value);

      const rx = degToRad(Number(viewXEl.value));
      const ry = degToRad(Number(viewYEl.value));
      const rz = degToRad(Number(viewZEl.value));

      clearCanvas();

      const full = { x0: 0, y0: 0, w: canvas.width, h: canvas.height };
      const left  = { x0: 0, y0: 0, w: canvas.width / 2, h: canvas.height };
      const right = { x0: canvas.width / 2, y0: 0, w: canvas.width / 2, h: canvas.height };

      if (splitEl.checked) {
        // изометрия (kx=ky=kz)
        drawViewportBorder(left);
        drawTitle("Изометрия", left);
        if (showAxesEl.checked) drawAxes("iso", coeff, rx, ry, rz, scale2d, left);
        drawWireframe(buildProjected(body, "iso", coeff, rx, ry, rz, scale2d, left), body.edges, "#2d3748", 2);

        // диметрия (kx=ky, kz=1/coeff)
        drawViewportBorder(right);
        drawTitle("Диметрия", right);
        if (showAxesEl.checked) drawAxes("dim", coeff, rx, ry, rz, scale2d, right);
        drawWireframe(buildProjected(body, "dim", coeff, rx, ry, rz, scale2d, right), body.edges, "#2d3748", 2);
      } else {
        // один режим (выбранный)
        const mode = "iso"; // по умолчанию можно показывать изо
        drawViewportBorder(full);
        drawTitle("Изометрия (один вид)", full);
        if (showAxesEl.checked) drawAxes(mode, coeff, rx, ry, rz, scale2d, full);
        drawWireframe(buildProjected(body, mode, coeff, rx, ry, rz, scale2d, full), body.edges, "#2d3748", 2);
      }
    }

    // ---------- Events ----------
    [
      bodyEl, splitEl,
      dimCoeffEl,
      viewXEl, viewYEl, viewZEl,
      showAxesEl,
      scaleEl
    ].forEach((n) => {
      n.addEventListener("input", render);
      n.addEventListener("change", render);
    });

    resetBtn.addEventListener("click", () => {
      bodyEl.value = "cube";
      splitEl.checked = true;

      dimCoeffEl.value = "2";

      // стартовый “классический” поворот вида
      viewXEl.value = "35.264";
      viewYEl.value = "45";
      viewZEl.value = "0";

      showAxesEl.checked = true;
      scaleEl.value = "1";
      render();
    });

    render();
  });
</script>



</body>

</html>