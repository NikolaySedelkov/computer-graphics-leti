<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Лабораторная работа по компьютерной графике</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">

  <style>
    body {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .main-container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
      overflow: hidden;
    }

    .header {
      background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
      color: white;
      padding: 30px;
      text-align: center;
    }

    .navigation {
      background: #2d3748;
      padding: 15px 30px;
      border-bottom: 3px solid #1a202c;
    }

    .nav-btn {
      min-width: 80px;
    }

    .nav-btn.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-color: #fff;
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.5);
    }

    .lab-info {
      background: #f7fafc;
      padding: 20px 30px;
      border-bottom: 2px solid #e2e8f0;
    }

    .canvas-wrapper {
      background: #f7fafc;
      border: 2px solid #cbd5e0;
      border-radius: 8px;
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #canvas {
      background: white;
      border: 1px solid #a0aec0;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .controls-panel {
      background: #f7fafc;
      border: 2px solid #cbd5e0;
      border-radius: 8px;
      padding: 25px;
      overflow-y: auto;
      max-height: 700px;
    }

    .controls-panel h3 {
      color: #2d3748;
      padding-bottom: 10px;
      border-bottom: 2px solid #cbd5e0;
    }

    .btn-gradient {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border: none;
      color: white;
    }

    .btn-gradient:hover {
      background: linear-gradient(135deg, #5568d3 0%, #6a3f8f 100%);
      color: white;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }
  </style>
</head>

<body>
  <div class="main-container">
    <!-- Заголовок курса -->
    <div class="header">
      <h1 class="mb-2">Лабораторная работа 1</h1>
      <h2 class="h4 fw-light opacity-75">Сформировать отрезок, касательный к двум заданным окружностям с
        внутренней стороны, определив предварительно координаты точек касания.
        Необходимо предусмотреть возможность редактирования положения и параметры окружностей.
      </h2>
    </div>

    <!-- Рабочая область -->
    <div class="row g-3 p-4">
      <!-- Область Canvas -->
      <div class="col-lg-8">
        <div class="canvas-wrapper">
          <canvas id="canvas" width="800" height="600"></canvas>
        </div>
      </div>

      <!-- Панель управления -->
      <div class="col-lg-4">
        <div class="controls-panel">
          <h3 class="h5 mb-3">Контроллеры</h3>

          <div id="controls">
            <div class="mb-3">
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="it_showSecond" checked>
                <label class="form-check-label" for="it_showSecond">Показать обе внутренние касательные (если
                  существуют)</label>
              </div>

              <div class="form-check mt-2">
                <input class="form-check-input" type="checkbox" id="it_showHelpers" checked>
                <label class="form-check-label" for="it_showHelpers">Показать вспомогательные построения</label>
              </div>

              <hr class="my-3">

              <div class="mt-2">
                <label class="form-label" for="it_r1">Радиус R1: <span id="it_r1Label">90</span></label>
                <input class="form-range" type="range" id="it_r1" min="5" max="250" step="1" value="90">
              </div>

              <div class="mt-2">
                <label class="form-label" for="it_r2">Радиус R2: <span id="it_r2Label">60</span></label>
                <input class="form-range" type="range" id="it_r2" min="5" max="250" step="1" value="60">
              </div>

              <hr class="my-3">
              <div class="small text-secondary">
                Перетаскивание: C1 — красная точка, C2 — синяя точка.
              </div>
            </div>

            <div class="d-grid gap-2">
              <button class="btn btn-outline-secondary" id="it_reset" type="button">Сброс</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // ---------- DOM ----------
        function requireEl(id) {
          const n = document.getElementById(id);
          if (!n) throw new Error(`Не найден элемент id="${id}"`);
          return n;
        }

        const canvas = requireEl("canvas");
        const ctx = canvas.getContext("2d");
        if (!ctx) throw new Error("canvas.getContext('2d') вернул null.");

        const showSecondEl = requireEl("it_showSecond");
        const showHelpersEl = requireEl("it_showHelpers");

        const r1El = requireEl("it_r1");
        const r2El = requireEl("it_r2");
        const r1Label = requireEl("it_r1Label");
        const r2Label = requireEl("it_r2Label");

        const resetBtn = requireEl("it_reset");

        // ---------- World mapping (0,0 center; Y up) ----------
        function clearCanvas() {
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function withWorld(drawFn) {
          const cx = canvas.width / 2;
          const cy = canvas.height / 2;
          ctx.save();
          ctx.setTransform(1, 0, 0, -1, cx, cy);
          drawFn();
          ctx.restore();
        }

        function screenToWorld(clientX, clientY) {
          const rect = canvas.getBoundingClientRect();
          const px = (clientX - rect.left) * (canvas.width / rect.width);
          const py = (clientY - rect.top) * (canvas.height / rect.height);
          const cx = canvas.width / 2;
          const cy = canvas.height / 2;
          return { x: px - cx, y: cy - py };
        }

        // ---------- Geometry helpers ----------
        function sub(a, b) { return { x: a.x - b.x, y: a.y - b.y }; }
        function add(a, b) { return { x: a.x + b.x, y: a.y + b.y }; }
        function mul(a, s) { return { x: a.x * s, y: a.y * s }; }
        function dot(a, b) { return a.x * b.x + a.y * b.y; }
        function norm(a) { return Math.hypot(a.x, a.y); }
        function normalize(a) { const n = norm(a) || 1; return { x: a.x / n, y: a.y / n }; }
        function perp(a) { return { x: -a.y, y: a.x }; } // +90°
        function dist2(a, b) { const dx = a.x - b.x, dy = a.y - b.y; return dx * dx + dy * dy; }

        // Точки касания из точки P к окружности (C, r) — 0/1/2 точек. [web:377]
        function tangentPointsPointCircle(P, C, r) {
          const v = sub(P, C);
          const d = norm(v);

          if (d < r - 1e-9) return { kind: "inside", points: [] };
          if (Math.abs(d - r) <= 1e-9) return { kind: "on", points: [{ x: P.x, y: P.y }] };

          const u = normalize(v);
          const n = perp(u);

          const a = (r * r) / d;
          const h = (r * Math.sqrt(d * d - r * r)) / d;

          const T1 = add(C, add(mul(u, a), mul(n, h)));
          const T2 = add(C, add(mul(u, a), mul(n, -h)));

          return { kind: "outside", points: [T1, T2] };
        }

        // ---------- Internal common tangents between circles ----------
        // Метод: внутренняя касательная для (C1,r1) и (C2,r2) эквивалентна касательной из C2
        // к окружности (C1, r1+r2) (в смысле направления), затем сдвиг по нормали даёт точки касания. [web:377][web:395]
        function internalCommonTangents(C1, r1, C2, r2) {
          const R = r1 + r2;

          // Если C2 внутри "расширенной" окружности — внутренних касательных нет
          const tang = tangentPointsPointCircle(C2, C1, R);
          if (tang.kind !== "outside") return { kind: tang.kind, tangents: [] };

          // Для каждой касательной строим прямую с нормалью n:
          // Если U — точка касания на расширенной окружности, то радиус C1U перпендикулярен касательной,
          // значит нормаль прямой n = normalize(U - C1).
          const tangents = tang.points.map((U) => {
            const n = normalize(sub(U, C1)); // нормаль к прямой (в сторону касания)
            const dir = perp(n);             // направление прямой

            // Общая внутренняя касательная к исходным окружностям:
            // линия L: n·X = n·U' (для окружности 1 касание на расстоянии r1 от C1)
            // точка касания на окружности 1:
            const T1 = add(C1, mul(n, r1));

            // на окружности 2 касание по противоположной стороне нормали:
            const T2 = add(C2, mul(n, -r2));

            return { n, dir, T1, T2 };
          });

          return { kind: "ok", tangents };
        }

        // ---------- Drawing primitives ----------
        function drawAxes() {
          withWorld(() => {
            ctx.strokeStyle = "#e2e8f0";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, 0);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, -canvas.height / 2);
            ctx.lineTo(0, canvas.height / 2);
            ctx.stroke();
          });
        }

        function drawCircle(C, r, stroke) {
          withWorld(() => {
            ctx.strokeStyle = stroke;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(C.x, C.y, r, 0, Math.PI * 2);
            ctx.stroke();
          });
        }

        function drawPoint(pt, color, radius = 6) {
          withWorld(() => {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(pt.x, pt.y, radius, 0, Math.PI * 2);
            ctx.fill();
          });
        }

        function drawSegment(a, b, style, width = 2, dashed = false) {
          withWorld(() => {
            ctx.save();
            ctx.strokeStyle = style;
            ctx.lineWidth = width;
            ctx.setLineDash(dashed ? [6, 6] : []);
            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(b.x, b.y);
            ctx.stroke();
            ctx.restore();
          });
        }

        function drawInfiniteLineThroughPointDir(P0, dir, style, width = 2) {
          const K = 2000;
          const A = add(P0, mul(dir, -K));
          const B = add(P0, mul(dir, K));
          drawSegment(A, B, style, width, false);
        }

        function drawStatusText(text) {
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.fillStyle = "#2d3748";
          ctx.font = "14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
          ctx.fillText(text, 12, 20);
          ctx.restore();
        }

        // ---------- State ----------
        let C1 = { x: -120, y: 0 };
        let C2 = { x: 180, y: 60 };
        let r1 = 90;
        let r2 = 60;

        // ---------- Render ----------
        function render() {
          r1 = Number(r1El.value);
          r2 = Number(r2El.value);
          r1Label.textContent = String(r1);
          r2Label.textContent = String(r2);

          clearCanvas();
          drawAxes();

          drawCircle(C1, r1, "#e53e3e");
          drawCircle(C2, r2, "#3182ce");

          const res = internalCommonTangents(C1, r1, C2, r2);

          if (res.kind !== "ok") {
            // Внутренних касательных нет, например когда окружности пересекаются/касаются. [web:377]
            drawStatusText("Внутренних общих касательных нет (окружности пересекаются/слишком близко).");
          } else {
            drawStatusText("Построены внутренние общие касательные.");

            const t0 = res.tangents[0];
            // основная касательная
            drawInfiniteLineThroughPointDir(t0.T1, t0.dir, "#2d3748", 2.5);
            drawSegment(t0.T1, t0.T2, "#2d3748", 3); // выделим именно отрезок между точками касания

            drawPoint(t0.T1, "#2d3748", 5);
            drawPoint(t0.T2, "#2d3748", 5);

            if (showHelpersEl.checked) {
              drawSegment(C1, t0.T1, "rgba(229,62,62,0.45)", 1.5, false);
              drawSegment(C2, t0.T2, "rgba(49,130,206,0.45)", 1.5, false);
            }

            if (showSecondEl.checked && res.tangents.length >= 2) {
              const t1 = res.tangents[1];
              drawInfiniteLineThroughPointDir(t1.T1, t1.dir, "#2d3748", 2.5);
              drawSegment(t1.T1, t1.T2, "#2d3748", 3);

              drawPoint(t1.T1, "#2d3748", 5);
              drawPoint(t1.T2, "#2d3748", 5);

              if (showHelpersEl.checked) {
                drawSegment(C1, t1.T1, "rgba(229,62,62,0.45)", 1.5, false);
                drawSegment(C2, t1.T2, "rgba(49,130,206,0.45)", 1.5, false);
              }
            }
          }

          // центры
          drawPoint(C1, "#e53e3e", 6);
          drawPoint(C2, "#3182ce", 6);

          if (showHelpersEl.checked && res.kind === "ok") {
            // линия центров
            drawSegment(C1, C2, "rgba(45,55,72,0.25)", 1.5, true);
          }
        }

        // ---------- Interaction (drag centers) ----------
        const DragKind = { NONE: 0, C1: 1, C2: 2 };
        const drag = { kind: DragKind.NONE };
        const HIT_R2 = 14 * 14;

        canvas.addEventListener("mousedown", (evt) => {
          const w = screenToWorld(evt.clientX, evt.clientY);
          if (dist2(w, C1) <= HIT_R2) { drag.kind = DragKind.C1; evt.preventDefault(); return; }
          if (dist2(w, C2) <= HIT_R2) { drag.kind = DragKind.C2; evt.preventDefault(); return; }
        });

        canvas.addEventListener("mousemove", (evt) => {
          if (drag.kind === DragKind.NONE) return;
          const w = screenToWorld(evt.clientX, evt.clientY);
          if (drag.kind === DragKind.C1) C1 = { x: w.x, y: w.y };
          if (drag.kind === DragKind.C2) C2 = { x: w.x, y: w.y };
          render();
        });

        function stopDrag() { drag.kind = DragKind.NONE; }
        window.addEventListener("mouseup", stopDrag);
        canvas.addEventListener("mouseleave", stopDrag);

        // ---------- Controls ----------
        [showSecondEl, showHelpersEl, r1El, r2El].forEach((n) => {
          n.addEventListener("input", render);
          n.addEventListener("change", render);
        });

        resetBtn.addEventListener("click", () => {
          C1 = { x: -120, y: 0 };
          C2 = { x: 180, y: 60 };
          r1El.value = "90";
          r2El.value = "60";
          showSecondEl.checked = true;
          showHelpersEl.checked = true;
          render();
        });

        render();
      });
    </script>


</body>

</html>